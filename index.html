<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SunSeeker â€” Find Your Light</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,600;1,300&family=DM+Mono:wght@300;400&display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/suncalc@1.9.0/suncalc.js"></script>
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #0c0c0d;
      --glass: rgba(10, 10, 11, 0.78);
      --glass-border: rgba(255, 255, 255, 0.07);
      --text: #ede8df;
      --muted: rgba(237, 232, 223, 0.38);
      --accent-gold: #e8a020;
      --accent-blue: #5b9ff5;
      --accent-purple: #a07edb;
    }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'DM Mono', monospace;
      height: 100dvh;
      overflow: hidden;
    }

    #map {
      width: 100vw;
      height: 100dvh;
      position: absolute;
      inset: 0;
    }

    /* â”€â”€â”€ Overlay layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #ui {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 20;
    }

    /* â”€â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #header {
      position: absolute;
      top: 0; left: 0; right: 0;
      display: flex;
      justify-content: center;
      padding-top: 28px;
    }

    #header h1 {
      font-family: 'Cormorant Garamond', serif;
      font-weight: 300;
      font-size: 20px;
      letter-spacing: 0.32em;
      text-transform: uppercase;
      color: var(--text);
      opacity: 0.85;
    }

    /* â”€â”€â”€ Phase badge (top-left) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #phase-badge {
      position: absolute;
      top: 24px;
      left: 24px;
      pointer-events: none;
      display: flex;
      align-items: center;
      gap: 9px;
      padding: 9px 15px;
      border-radius: 9px;
      font-size: 11px;
      letter-spacing: 0.1em;
      border: 1px solid transparent;
      transition: all 0.6s ease;
      opacity: 0;
    }

    #phase-badge.visible { opacity: 1; }

    #phase-badge.golden {
      background: rgba(232, 160, 32, 0.13);
      border-color: rgba(232, 160, 32, 0.35);
      color: #f0bf55;
    }

    #phase-badge.blue {
      background: rgba(91, 159, 245, 0.11);
      border-color: rgba(91, 159, 245, 0.32);
      color: #8dbfff;
    }

    #phase-badge.civil {
      background: rgba(160, 126, 219, 0.1);
      border-color: rgba(160, 126, 219, 0.28);
      color: #c0a0ff;
    }

    .badge-icon {
      font-size: 14px;
      line-height: 1;
    }

    .badge-dot {
      width: 5px; height: 5px;
      border-radius: 50%;
      background: currentColor;
      animation: throb 2.4s ease-in-out infinite;
      flex-shrink: 0;
    }

    @keyframes throb {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.25; transform: scale(0.7); }
    }

    /* â”€â”€â”€ Solar info panel (top-right) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #solar-panel {
      position: absolute;
      top: 24px; right: 24px;
      pointer-events: none;
      background: var(--glass);
      border: 1px solid var(--glass-border);
      backdrop-filter: blur(24px) saturate(1.2);
      -webkit-backdrop-filter: blur(24px) saturate(1.2);
      border-radius: 13px;
      padding: 18px 20px;
      width: 210px;
    }

    .panel-label {
      font-size: 8.5px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 14px;
    }

    .solar-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      padding: 4px 0;
    }

    .solar-row + .solar-row {
      border-top: 1px solid rgba(255,255,255,0.04);
    }

    .solar-key {
      font-size: 9.5px;
      color: var(--muted);
      letter-spacing: 0.04em;
    }

    .solar-val {
      font-size: 12.5px;
      color: var(--text);
      transition: color 0.4s;
    }

    .sep {
      height: 1px;
      background: rgba(255,255,255,0.06);
      margin: 10px 0;
    }

    /* â”€â”€â”€ Sun compass (right, above controls) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #compass-wrap {
      position: absolute;
      bottom: 72px;
      right: 16px;
      pointer-events: all;
      cursor: grab;
      user-select: none;
      -webkit-user-select: none;
    }

    #compass-wrap.dragging {
      cursor: grabbing;
    }

    #compass-wrap canvas {
      display: block;
    }

    #compass-hint {
      text-align: center;
      font-size: 8px;
      letter-spacing: 0.12em;
      color: rgba(237,232,223,0.25);
      margin-top: 5px;
      text-transform: uppercase;
      transition: opacity 0.3s;
    }

    #compass-wrap:hover #compass-hint {
      color: rgba(237,232,223,0.45);
    }

    /* â”€â”€â”€ Controls bar (bottom center) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #controls {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      pointer-events: all;
      background: var(--glass);
      border: 1px solid var(--glass-border);
      backdrop-filter: blur(20px) saturate(1.2);
      -webkit-backdrop-filter: blur(20px) saturate(1.2);
      border-radius: 14px;
      padding: 7px 10px;
      display: flex;
      align-items: center;
      gap: 2px;
      white-space: nowrap;
      max-width: calc(100vw - 32px);
    }

    .ctrl-input {
      background: transparent;
      border: none;
      border-radius: 7px;
      color: var(--text);
      font-family: 'DM Mono', monospace;
      font-size: 12px;
      padding: 6px 6px;
      outline: none;
      cursor: pointer;
      transition: background 0.15s;
      color-scheme: dark;
      /* clamp width so time/date don't over-expand */
      min-width: 0;
    }
    #inp-date  { width: 112px; }
    #inp-time  { width: 106px; } /* wide enough for HH:MM AM/PM */

    .ctrl-input:hover  { background: rgba(255,255,255,0.07); }
    .ctrl-input:focus  { background: rgba(255,255,255,0.09); }

    .vr {
      width: 1px;
      height: 20px;
      background: rgba(255,255,255,0.1);
      flex-shrink: 0;
      margin: 0 3px;
    }

    /* shared pill-button style for all bar icon-buttons */
    .bar-btn {
      background: transparent;
      border: none;
      border-radius: 7px;
      color: var(--muted);
      font-family: 'DM Mono', monospace;
      font-size: 11px;
      letter-spacing: 0.03em;
      padding: 6px 8px;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
      display: flex;
      align-items: center;
      gap: 5px;
      white-space: nowrap;
      flex-shrink: 0;
    }
    .bar-btn:hover  { background: rgba(255,255,255,0.07); color: var(--text); }

    #locate-btn { color: var(--muted); }
    #locate-btn svg { flex-shrink: 0; }



    /* â”€â”€â”€ Sun ray canvas overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #ray-canvas {
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.8s;
    }

    /* â”€â”€â”€ Map attribution override â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .maplibregl-ctrl-attrib {
      font-size: 9px !important;
      opacity: 0.4;
    }

    /* â”€â”€â”€ Light Times Panel (left side) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #light-times {
      position: absolute;
      left: 16px;
      bottom: 72px;
      pointer-events: none;
      background: var(--glass);
      border: 1px solid var(--glass-border);
      backdrop-filter: blur(24px) saturate(1.2);
      -webkit-backdrop-filter: blur(24px) saturate(1.2);
      border-radius: 13px;
      padding: 16px 18px;
      width: 220px;
    }

    #light-times .panel-label {
      margin-bottom: 12px;
    }

    .lt-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 5px 0;
    }

    .lt-row + .lt-row {
      border-top: 1px solid rgba(255,255,255,0.04);
    }

    .lt-swatch {
      width: 26px;
      height: 26px;
      border-radius: 7px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    .lt-info {
      flex: 1;
      min-width: 0;
    }

    .lt-name {
      font-size: 9px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 2px;
    }

    .lt-time {
      font-size: 12.5px;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .lt-time.active {
      color: #f0bf55;
      text-shadow: 0 0 12px rgba(232,160,32,0.4);
    }

    /* Day arc bar at bottom of panel */
    #day-arc-wrap {
      margin-top: 13px;
      padding-top: 11px;
      border-top: 1px solid rgba(255,255,255,0.06);
    }

    #day-arc-label {
      font-size: 8px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 7px;
    }

    #day-arc-bar {
      position: relative;
      height: 8px;
      border-radius: 4px;
      background: rgba(255,255,255,0.05);
      overflow: visible;
    }

    .arc-seg {
      position: absolute;
      top: 0; height: 100%;
      border-radius: 4px;
      transition: left 0.5s ease, width 0.5s ease;
    }

    #arc-cursor {
      position: absolute;
      top: -4px;
      width: 3px;
      height: 16px;
      border-radius: 2px;
      background: white;
      box-shadow: 0 0 6px rgba(255,255,255,0.6);
      transform: translateX(-50%);
      transition: left 0.5s ease;
      z-index: 2;
    }

    /* â”€â”€â”€ Info tooltip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .info-badge {
      pointer-events: all;
      position: relative;
      width: 18px; height: 18px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(255,255,255,0.06);
      color: var(--muted);
      font-family: 'Cormorant Garamond', serif;
      font-style: italic;
      font-size: 12px;
      line-height: 1;
      display: flex; align-items: center; justify-content: center;
      cursor: default;
      flex-shrink: 0;
      transition: border-color 0.2s, color 0.2s;
    }

    .info-badge:hover {
      border-color: rgba(255,255,255,0.35);
      color: var(--text);
    }

    .info-tooltip {
      display: none;
      position: absolute;
      bottom: calc(100% + 10px);
      left: 50%;
      transform: translateX(-50%);
      width: 230px;
      background: rgba(8, 8, 12, 0.96);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 13px 15px;
      font-family: 'DM Mono', monospace;
      font-size: 10.5px;
      line-height: 1.65;
      color: rgba(237,232,223,0.7);
      pointer-events: none;
      z-index: 100;
      text-align: left;
      white-space: normal;
    }

    .info-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: rgba(255,255,255,0.1);
    }

    .info-tooltip::before {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 5px solid transparent;
      border-top-color: rgba(8,8,12,0.96);
      z-index: 1;
    }

    .info-tooltip-title {
      font-size: 9px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: rgba(237,232,223,0.35);
      margin-bottom: 8px;
    }

    .info-tooltip ul {
      padding-left: 14px;
      margin: 0;
    }

    .info-tooltip li {
      margin-bottom: 5px;
      padding-left: 2px;
    }

    .info-tooltip li:last-child { margin-bottom: 0; }

    .info-badge:hover .info-tooltip {
      display: block;
    }



    /* â”€â”€â”€ Shadow refresh button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #refresh-btn {
      background: transparent;
      border: none;
      border-radius: 7px;
      color: var(--muted);
      padding: 6px 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s, color 0.15s, transform 0.3s;
      flex-shrink: 0;
    }
    #refresh-btn:hover { background: rgba(255,255,255,0.07); color: var(--text); }
    #refresh-btn.spinning svg { animation: refreshSpin 0.6s ease-in-out; }
    @keyframes refreshSpin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

    /* â”€â”€â”€ Search (embedded in bottom bar) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #search-wrap {
      position: relative;
      display: flex;
      align-items: center;
      pointer-events: all;
      flex-shrink: 0;
    }

    #search-toggle {
      background: transparent;
      border: none;
      border-radius: 7px;
      color: var(--muted);
      padding: 6px 9px;
      cursor: pointer;
      display: flex;
      align-items: center;
      transition: background 0.15s, color 0.15s;
      /* make tap target comfortable */
      min-width: 36px;
      justify-content: center;
    }
    #search-toggle:hover, #search-wrap.open #search-toggle {
      background: rgba(255,255,255,0.07);
      color: var(--text);
    }

    /* When open, a floating panel appears above â€” centered on the bar */
    #search-popup {
      display: none;
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      width: 280px;
      background: rgba(8, 8, 12, 0.97);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 13px;
      overflow: hidden;
      z-index: 100;
      animation: popUp 0.18s ease;
    }
    @keyframes popUp {
      from { opacity: 0; transform: translateX(-50%) translateY(6px); }
      to   { opacity: 1; transform: translateX(-50%) translateY(0); }
    }
    #search-wrap.open #search-popup { display: block; }

    #search-input-row {
      display: flex;
      align-items: center;
      padding: 0 12px;
      border-bottom: 1px solid rgba(255,255,255,0.07);
      gap: 8px;
    }
    #search-input-row svg { flex-shrink: 0; opacity: 0.4; }

    #search-inp {
      flex: 1;
      background: transparent;
      border: none;
      outline: none;
      color: var(--text);
      font-family: 'DM Mono', monospace;
      font-size: 12px;
      padding: 11px 0;
      min-width: 0;
      letter-spacing: 0.02em;
    }
    #search-inp::placeholder { color: var(--muted); }

    #search-clear {
      background: none;
      border: none;
      color: var(--muted);
      cursor: pointer;
      padding: 3px 4px;
      display: none;
      line-height: 1;
      font-size: 15px;
      flex-shrink: 0;
    }
    #search-clear:hover { color: var(--text); }

    #search-results { /* inside popup, no positioning needed */ }

    .sr-item {
      padding: 9px 13px;
      cursor: pointer;
      transition: background 0.15s;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .sr-item:last-child { border-bottom: none; }
    .sr-item:hover { background: rgba(255,255,255,0.07); }

    .sr-name {
      font-size: 12px;
      color: var(--text);
      margin-bottom: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .sr-detail {
      font-size: 9.5px;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .sr-empty {
      padding: 11px 13px;
      font-size: 11px;
      color: var(--muted);
      text-align: center;
    }

    #search-spinner {
      display: none;
      width: 11px; height: 11px;
      border: 1.5px solid rgba(255,255,255,0.15);
      border-top-color: var(--text);
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
      flex-shrink: 0;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* â”€â”€â”€ Mobile solar drawer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #mobile-solar-btn {
      display: none; /* only shown on mobile */
      position: absolute;
      top: 24px; right: 24px;
      pointer-events: all;
      background: var(--glass);
      border: 1px solid var(--glass-border);
      backdrop-filter: blur(24px);
      -webkit-backdrop-filter: blur(24px);
      border-radius: 12px;
      padding: 9px 14px;
      color: var(--text);
      font-family: 'DM Mono', monospace;
      font-size: 11px;
      letter-spacing: 0.06em;
      cursor: pointer;
      display: none;
      align-items: center;
      gap: 8px;
      transition: background 0.2s, border-color 0.2s;
      z-index: 30;
    }

    #mobile-solar-btn:hover {
      background: rgba(255,255,255,0.1);
      border-color: rgba(255,255,255,0.18);
    }

    #mobile-solar-btn .msb-phase-dot {
      width: 7px; height: 7px;
      border-radius: 50%;
      background: var(--accent-gold);
      flex-shrink: 0;
      transition: background 0.4s;
    }

    /* The drawer sits below the button */
    #mobile-solar-drawer {
      display: none; /* toggled by JS */
      position: absolute;
      top: 68px; right: 24px;
      pointer-events: all;
      background: rgba(8, 8, 12, 0.97);
      border: 1px solid rgba(255,255,255,0.1);
      backdrop-filter: blur(24px);
      -webkit-backdrop-filter: blur(24px);
      border-radius: 14px;
      padding: 18px 20px;
      width: 230px;
      z-index: 30;
      animation: drawerSlide 0.22s ease;
    }

    @keyframes drawerSlide {
      from { opacity: 0; transform: translateY(-8px); }
      to   { opacity: 1; transform: translateY(0); }
    }

    /* â”€â”€â”€ Responsive â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    @media (max-width: 600px) {
      #controls { gap: 1px; padding: 6px 8px; bottom: 12px; }
      .vr { display: none; }
      #solar-panel { display: none !important; }
      #compass-wrap { display: none; }
      #mobile-solar-btn { display: flex !important; }
      /* keep search popup full-width on mobile */
      #search-popup { width: calc(100vw - 40px); left: auto; right: 0; transform: none; }
      @keyframes popUp {
        from { opacity: 0; transform: translateY(6px); }
        to   { opacity: 1; transform: translateY(0); }
      }
    }
  </style>
</head>
<body>

<div id="map"></div>
<canvas id="ray-canvas"></canvas>

<div id="ui">

  <!-- Header (hidden on desktop â€“ search takes its place) -->
  <div id="header" style="display:none"><h1>SunSeeker</h1></div>



  <!-- Phase badge -->
  <div id="phase-badge">
    <span class="badge-dot"></span>
    <span class="badge-icon" id="badge-icon"></span>
    <span id="badge-text"></span>
  </div>

  <!-- Solar info -->
  <div id="solar-panel">
    <div class="panel-label">Solar Position</div>
    <div class="solar-row">
      <span class="solar-key">Azimuth</span>
      <span class="solar-val" id="v-azimuth">â€”</span>
    </div>
    <div class="solar-row">
      <span class="solar-key">Altitude</span>
      <span class="solar-val" id="v-altitude">â€”</span>
    </div>
    <div class="solar-row">
      <span class="solar-key">Phase</span>
      <span class="solar-val" id="v-phase">â€”</span>
    </div>
    <div class="sep"></div>
    <div class="solar-row">
      <span class="solar-key">Sunrise</span>
      <span class="solar-val" id="v-sunrise">â€”</span>
    </div>
    <div class="solar-row">
      <span class="solar-key">Sunset</span>
      <span class="solar-val" id="v-sunset">â€”</span>
    </div>
    <div class="solar-row">
      <span class="solar-key">Morning âœ¦</span>
      <span class="solar-val" id="lt-golden-morn">â€”</span>
    </div>
    <div class="solar-row">
      <span class="solar-key">Evening âœ¦</span>
      <span class="solar-val" id="lt-golden-eve">â€”</span>
    </div>
    <div id="day-arc-wrap">
      <div id="day-arc-label">Daylight Span</div>
      <div id="day-arc-bar">
        <div class="arc-seg" id="arc-blue-morn"  style="background:rgba(91,159,245,0.55)"></div>
        <div class="arc-seg" id="arc-golden-morn" style="background:rgba(232,160,32,0.75)"></div>
        <div class="arc-seg" id="arc-day"         style="background:rgba(255,245,200,0.2)"></div>
        <div class="arc-seg" id="arc-golden-eve"  style="background:rgba(232,160,32,0.75)"></div>
        <div class="arc-seg" id="arc-blue-eve"    style="background:rgba(91,159,245,0.55)"></div>
        <div id="arc-cursor"></div>
      </div>
    </div>
  </div>

  <!-- Mobile solar button + drawer -->
  <button id="mobile-solar-btn">
    <div class="msb-phase-dot" id="msb-dot"></div>
    <span id="msb-label">Sun Info</span>
    <svg id="msb-chevron" width="10" height="10" viewBox="0 0 10 10" fill="none" style="transition:transform 0.22s;margin-left:2px">
      <path d="M2 3.5L5 6.5L8 3.5" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  </button>

  <div id="mobile-solar-drawer">
    <div class="panel-label">Solar Position</div>
    <div class="solar-row">
      <span class="solar-key">Phase</span>
      <span class="solar-val" id="mv-phase">â€”</span>
    </div>
    <div class="solar-row">
      <span class="solar-key">Azimuth</span>
      <span class="solar-val" id="mv-azimuth">â€”</span>
    </div>
    <div class="solar-row">
      <span class="solar-key">Altitude</span>
      <span class="solar-val" id="mv-altitude">â€”</span>
    </div>
    <div class="sep"></div>
    <div class="solar-row">
      <span class="solar-key">Sunrise</span>
      <span class="solar-val" id="mv-sunrise">â€”</span>
    </div>
    <div class="solar-row">
      <span class="solar-key">Sunset</span>
      <span class="solar-val" id="mv-sunset">â€”</span>
    </div>
    <div class="sep"></div>
    <div class="solar-row">
      <span class="solar-key">Morning âœ¦</span>
      <span class="solar-val" id="mv-golden-morn">â€”</span>
    </div>
    <div class="solar-row">
      <span class="solar-key">Evening âœ¦</span>
      <span class="solar-val" id="mv-golden-eve">â€”</span>
    </div>
    <div id="day-arc-wrap-m" style="margin-top:12px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.06)">
      <div style="font-size:8px;letter-spacing:0.14em;text-transform:uppercase;color:var(--muted);margin-bottom:7px">Daylight Span</div>
      <div style="position:relative;height:8px;border-radius:4px;background:rgba(255,255,255,0.05);overflow:visible">
        <div class="arc-seg" id="arc-blue-morn-m"  style="background:rgba(91,159,245,0.55)"></div>
        <div class="arc-seg" id="arc-golden-morn-m" style="background:rgba(232,160,32,0.75)"></div>
        <div class="arc-seg" id="arc-day-m"         style="background:rgba(255,245,200,0.2)"></div>
        <div class="arc-seg" id="arc-golden-eve-m"  style="background:rgba(232,160,32,0.75)"></div>
        <div class="arc-seg" id="arc-blue-eve-m"    style="background:rgba(91,159,245,0.55)"></div>
        <div id="arc-cursor-m" style="position:absolute;top:-4px;width:3px;height:16px;border-radius:2px;background:white;box-shadow:0 0 6px rgba(255,255,255,0.6);transform:translateX(-50%);transition:left 0.5s ease;z-index:2"></div>
      </div>
    </div>
  </div>

  <!-- Compass -->
  <div id="compass-wrap">
    <canvas id="compass" width="110" height="110"></canvas>
    <div id="compass-hint">drag to rotate</div>
  </div>



  <!-- Controls â€” compact single row -->
  <div id="controls">
    <input type="date" class="ctrl-input" id="inp-date">
    <div class="vr"></div>
    <input type="time" class="ctrl-input" id="inp-time">

    <div class="vr"></div>
    <button id="locate-btn" class="bar-btn" title="My Location">
      <svg width="12" height="12" viewBox="0 0 12 12" fill="none">
        <circle cx="6" cy="6" r="2.2" fill="currentColor"/>
        <path d="M6 1v1.5M6 9.5V11M1 6h1.5M9.5 6H11" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"/>
        <circle cx="6" cy="6" r="4.5" stroke="currentColor" stroke-width="1" opacity="0.5"/>
      </svg>
    </button>
    <div class="info-badge">
      i
      <div class="info-tooltip">
        <div class="info-tooltip-title">Shadow Approximations</div>
        <ul>
          <li>Shadows use convex hull outlines, so concave or L-shaped buildings cast slightly oversized shadows.</li>
          <li>Buildings don't block each other â€” overlapping shadows stack rather than merge.</li>
          <li>Heights come from map tile data, which may be missing or estimated for some buildings.</li>
          <li>Very low sun angles (&lt;5Â°) are capped to avoid city-spanning shadows.</li>
        </ul>
      </div>
    </div>
    <button id="refresh-btn" title="Refresh shadows">
      <svg width="13" height="13" viewBox="0 0 13 13" fill="none">
        <path d="M11 6.5A4.5 4.5 0 1 1 8.5 2.5" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"/>
        <path d="M8.5 1V3.5H11" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
    <div class="vr"></div>
    <!-- Search: icon toggles upward popup -->
    <div id="search-wrap">
      <button id="search-toggle" class="bar-btn" title="Search">
        <svg width="13" height="13" viewBox="0 0 13 13" fill="none">
          <circle cx="5.5" cy="5.5" r="4" stroke="currentColor" stroke-width="1.4"/>
          <path d="M8.5 8.5L11.5 11.5" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"/>
        </svg>
      </button>
      <div id="search-popup">
        <div id="search-input-row">
          <svg width="13" height="13" viewBox="0 0 13 13" fill="none">
            <circle cx="5.5" cy="5.5" r="4" stroke="currentColor" stroke-width="1.4"/>
            <path d="M8.5 8.5L11.5 11.5" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"/>
          </svg>
          <input id="search-inp" type="text" placeholder="Search place, address, businessâ€¦" autocomplete="off" spellcheck="false">
          <div id="search-spinner"></div>
          <button id="search-clear">Ã—</button>
        </div>
        <div id="search-results"></div>
      </div>
    </div>
  </div>

</div>

<script>
window.addEventListener('load', function() {
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STATE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let map;
let lat = 40.7484, lng = -73.9967; // Default: Midtown NYC
let lastSunData = null;
let shadowsEnabled = true;   // always on
let shadowUpdateTimer = null;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   DATE / TIME INIT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const pad = n => String(n).padStart(2, '0');

function nowLocal() { return new Date(); }

function setInputsToNow() {
  const d = nowLocal();
  document.getElementById('inp-date').value =
    `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
  document.getElementById('inp-time').value =
    `${pad(d.getHours())}:${pad(d.getMinutes())}`;
}

setInputsToNow();

function getSelectedDate() {
  const dv = document.getElementById('inp-date').value;
  const tv = document.getElementById('inp-time').value;
  if (!dv || !tv) return nowLocal();
  return new Date(`${dv}T${tv}:00`);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MAP INIT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
map = new maplibregl.Map({
  container: 'map',
  style: 'https://tiles.openfreemap.org/styles/liberty',
  center: [lng, lat],
  zoom: 16,
  pitch: 52,
  bearing: -20,
  antialias: true,
  attributionControl: true
});

map.addControl(new maplibregl.NavigationControl({ showCompass: false }), 'bottom-left');

map.on('load', () => {
  tryAdd3DBuildings();
  updateAll();
});

function tryAdd3DBuildings() {
  const style = map.getStyle();
  const layers = style.layers || [];

  // Find first symbol layer (insert buildings below labels)
  let beforeId;
  for (const l of layers) {
    if (l.type === 'symbol') { beforeId = l.id; break; }
  }

  // Remove any existing 3d-buildings layer we added
  if (map.getLayer('ss-buildings')) map.removeLayer('ss-buildings');

  // Detect the source name used for vector tiles
  const sources = Object.keys(style.sources || {});
  const vectorSource = sources.find(s => {
    const src = style.sources[s];
    return src.type === 'vector';
  });

  if (!vectorSource) return; // Raster-only style, skip

  try {
    map.addLayer({
      id: 'ss-buildings',
      type: 'fill-extrusion',
      source: vectorSource,
      'source-layer': 'building',
      minzoom: 14,
      paint: {
        'fill-extrusion-color': [
          'interpolate', ['linear'], ['zoom'],
          14, '#1e1e22',
          17, '#2a2a30'
        ],
        'fill-extrusion-height': [
          'coalesce', ['get', 'render_height'], ['get', 'height'], 5
        ],
        'fill-extrusion-base': [
          'coalesce', ['get', 'render_min_height'], ['get', 'min_height'], 0
        ],
        'fill-extrusion-opacity': 0.88
      }
    }, beforeId);
  } catch(e) {
    // Try common alternative source-layer names
    try {
      map.addLayer({
        id: 'ss-buildings',
        type: 'fill-extrusion',
        source: vectorSource,
        'source-layer': 'buildings',
        minzoom: 14,
        paint: {
          'fill-extrusion-color': '#202028',
          'fill-extrusion-height': ['coalesce', ['get', 'height'], 5],
          'fill-extrusion-base': ['coalesce', ['get', 'min_height'], 0],
          'fill-extrusion-opacity': 0.85
        }
      }, beforeId);
    } catch(e2) { /* style may handle buildings natively */ }
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SUN PHASE LOGIC
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function getSunPhase(altDeg) {
  if (altDeg < -18) return {
    name: 'Night', abbr: 'Night', color: '#202040',
    lightColor: '#0a0a18', lightInt: 0.1, badge: null
  };
  if (altDeg < -12) return {
    name: 'Astronomical Twilight', abbr: 'Astro Twilight', color: '#1e2045',
    lightColor: '#10103a', lightInt: 0.15, badge: null
  };
  if (altDeg < -6) return {
    name: 'Nautical Twilight', abbr: 'Nautical Twil.', color: '#252660',
    lightColor: '#181858', lightInt: 0.2, badge: null
  };
  if (altDeg < -4) return {
    name: 'Civil Twilight', abbr: 'Civil Twilight', color: '#4a3090',
    lightColor: '#2a1a60', lightInt: 0.25, badge: 'civil', icon: 'ğŸŒ†'
  };
  if (altDeg < 0) return {
    name: 'Blue Hour', abbr: 'Blue Hour', color: '#4a80e0',
    lightColor: '#3060c0', lightInt: 0.4, badge: 'blue', icon: 'ğŸ”µ'
  };
  if (altDeg < 6) return {
    name: 'Golden Hour', abbr: 'Golden Hour', color: '#e8a020',
    lightColor: '#d07010', lightInt: 0.72, badge: 'golden', icon: 'âœ¦'
  };
  if (altDeg < 20) return {
    name: 'Low Sun', abbr: 'Low Sun', color: '#d4a855',
    lightColor: '#c09040', lightInt: 0.6, badge: null
  };
  if (altDeg < 45) return {
    name: 'Daytime', abbr: 'Daytime', color: '#f5efdf',
    lightColor: '#f0e8d0', lightInt: 0.5, badge: null
  };
  return {
    name: 'High Sun', abbr: 'High Sun', color: '#ffffff',
    lightColor: '#ffffff', lightInt: 0.45, badge: null
  };
}

function fmtTime(d) {
  if (!d || isNaN(d.getTime())) return 'â€”';
  return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function azToCardinal(deg) {
  const dirs = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'];
  return dirs[Math.round(((deg % 360) + 360) % 360 / 22.5) % 16];
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MAIN UPDATE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function updateAll() {
  const date = getSelectedDate();
  const pos = SunCalc.getPosition(date, lat, lng);
  const times = SunCalc.getTimes(date, lat, lng);

  const altDeg = pos.altitude * 180 / Math.PI;
  // SunCalc azimuth: measured from south, going west-negative / east-positive
  // Convert to compass bearing: 0=N, 90=E, 180=S, 270=W
  const azDeg = ((pos.azimuth * 180 / Math.PI) + 180 + 360) % 360;

  const phase = getSunPhase(altDeg);
  lastSunData = { altDeg, azDeg, phase, times, date };

  updateLightTimes(times, date);
  updateInfoPanel(altDeg, azDeg, phase, times);
  updateBadge(phase);
  updateMapLight(altDeg, azDeg, phase);
  drawCompass(azDeg, altDeg, phase);
  drawRayOverlay(azDeg, altDeg, phase);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   LIGHT TIMES PANEL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function updateLightTimes(times, date) {
  const ghMornStart = times.dawn;          // civil dawn ~ blue hour start
  const ghMornEnd   = times.goldenHourEnd; // golden hour ends in morning
  const ghEveStart  = times.goldenHour;    // golden hour starts in evening
  const ghEveEnd    = times.dusk;          // civil dusk ~ blue hour end

  const fmtRange = (a, b) => {
    if (!a || !b || isNaN(a.getTime()) || isNaN(b.getTime())) return 'â€”';
    return fmtTime(a) + ' â€“ ' + fmtTime(b);
  };

  const fmtGoldenMorn = fmtRange(times.sunriseEnd, times.goldenHourEnd);
  const fmtGoldenEve  = fmtRange(times.goldenHour, times.sunsetStart);
  const el = (id, val) => { const e = document.getElementById(id); if(e) e.textContent = val; };

  // Solar panel (desktop) golden hour rows
  el('lt-golden-morn', fmtGoldenMorn);
  el('lt-golden-eve',  fmtGoldenEve);

  // Mobile drawer
  el('mv-golden-morn', fmtGoldenMorn);
  el('mv-golden-eve',  fmtGoldenEve);

  // Active highlighting (solar panel values are solar-val spans)
  const now = date;
  const inGoldenMorn = now >= times.sunriseEnd && now <= times.goldenHourEnd;
  const inGoldenEve  = now >= times.goldenHour  && now <= times.sunsetStart;
  const gmEl = document.getElementById('lt-golden-morn');
  const geEl = document.getElementById('lt-golden-eve');
  if (gmEl) { gmEl.style.color = inGoldenMorn ? '#f0bf55' : ''; gmEl.style.textShadow = inGoldenMorn ? '0 0 10px rgba(232,160,32,0.5)' : ''; }
  if (geEl) { geEl.style.color = inGoldenEve  ? '#f0bf55' : ''; geEl.style.textShadow = inGoldenEve  ? '0 0 10px rgba(232,160,32,0.5)' : ''; }

  // â”€â”€ Day arc bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Span the bar from civil dawn to civil dusk
  const dayStart = ghMornStart && !isNaN(ghMornStart) ? ghMornStart : times.sunrise;
  const dayEnd   = ghEveEnd    && !isNaN(ghEveEnd)    ? ghEveEnd   : times.sunset;
  if (!dayStart || !dayEnd || isNaN(dayStart) || isNaN(dayEnd)) return;

  const span = dayEnd - dayStart;
  const pct = t => {
    if (!t || isNaN(t.getTime())) return null;
    return Math.max(0, Math.min(100, (t - dayStart) / span * 100));
  };

  const seg = (id, from, to) => {
    const el = document.getElementById(id);
    const f = pct(from), t = pct(to);
    if (f === null || t === null) { el.style.display = 'none'; return; }
    el.style.display = '';
    el.style.left  = f + '%';
    el.style.width = Math.max(0, t - f) + '%';
  };

  const arcPairs = [
    ['arc-blue-morn',   'arc-blue-morn-m',   times.dawn,         times.sunrise],
    ['arc-golden-morn', 'arc-golden-morn-m',  times.sunriseEnd,   times.goldenHourEnd],
    ['arc-day',         'arc-day-m',          times.goldenHourEnd, times.goldenHour],
    ['arc-golden-eve',  'arc-golden-eve-m',   times.goldenHour,   times.sunsetStart],
    ['arc-blue-eve',    'arc-blue-eve-m',     times.sunset,       times.dusk],
  ];
  arcPairs.forEach(([id, idM, from, to]) => {
    [id, idM].forEach(i => { if(i) seg(i, from, to); });
  });

  // Cursor (desktop + mobile)
  const cursorPct = pct(now);
  ['arc-cursor', 'arc-cursor-m'].forEach(cid => {
    const cursor = document.getElementById(cid);
    if (!cursor) return;
    if (cursorPct !== null) { cursor.style.display = ''; cursor.style.left = cursorPct + '%'; }
    else { cursor.style.display = 'none'; }
  });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   INFO PANEL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function updateInfoPanel(altDeg, azDeg, phase, times) {
  document.getElementById('v-azimuth').textContent =
    `${azDeg.toFixed(1)}Â° ${azToCardinal(azDeg)}`;
  document.getElementById('v-altitude').textContent =
    `${altDeg.toFixed(1)}Â°`;

  const phaseEl = document.getElementById('v-phase');
  phaseEl.textContent = phase.abbr;
  phaseEl.style.color = phase.color;

  document.getElementById('v-sunrise').textContent = fmtTime(times.sunrise);
  document.getElementById('v-sunset').textContent = fmtTime(times.sunset);

  // Golden hour windows
  const ghMorn = times.goldenHourEnd;
  const ghEve = times.goldenHour;
  let ghStr = 'â€”';
  if (ghMorn && ghEve && !isNaN(ghMorn) && !isNaN(ghEve)) {
    ghStr = `${fmtTime(times.goldenHourEnd)} & ${fmtTime(times.goldenHour)}`;
  }
  document.getElementById('v-golden').textContent = ghStr;

  // Sync mobile drawer
  const isMobile = window.innerWidth <= 600;
  if (isMobile) {
    const mPhase = document.getElementById('mv-phase');
    if (mPhase) {
      mPhase.textContent = phase.abbr;
      mPhase.style.color = phase.color;
    }
    const el = (id, val) => { const e = document.getElementById(id); if(e) e.textContent = val; };
    el('mv-azimuth', `${azDeg.toFixed(1)}Â° ${azToCardinal(azDeg)}`);
    el('mv-altitude', `${altDeg.toFixed(1)}Â°`);
    el('mv-sunrise', fmtTime(times.sunrise));
    el('mv-sunset',  fmtTime(times.sunset));
    // update button label phase dot color
    const dot = document.getElementById('msb-dot');
    if (dot) dot.style.background = phase.color;
    const lbl = document.getElementById('msb-label');
    if (lbl) lbl.textContent = phase.abbr;
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   BADGE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function updateBadge(phase) {
  const badge = document.getElementById('phase-badge');
  badge.className = '';
  if (phase.badge) {
    badge.className = `visible ${phase.badge}`;
    document.getElementById('badge-icon').textContent = phase.icon;
    document.getElementById('badge-text').textContent = phase.name;
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MAP LIGHT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* â”€â”€ Sky color keyframes keyed to solar altitude â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Each entry: [altDeg, [R,G,B], intensity]
   Interpolated smoothly between adjacent entries.
   Values based on atmospheric scattering physics:
   - Deep night: near black
   - Astronomical/nautical twilight: deep indigo
   - Civil twilight / blue hour: rich cobalt-steel
   - Sunrise/sunset: fiery amber-orange
   - Golden hour: warm amber-gold
   - Low sun (<20Â°): pale warm yellow
   - High sun: near white with slight warmth
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const SKY_KEYS = [
  [-18,  [  8,   8,  18], 0.08],  // deep night
  [-12,  [ 14,  14,  42], 0.13],  // astronomical twilight
  [ -6,  [ 22,  28,  80], 0.20],  // nautical twilight
  [ -4,  [ 38,  52, 140], 0.28],  // civil twilight
  [ -1,  [ 60,  90, 180], 0.38],  // blue hour peak
  [  0,  [210, 100,  30], 0.55],  // exact horizon (sunrise/sunset)
  [  2,  [230, 130,  20], 0.72],  // golden hour warm
  [  5,  [220, 150,  40], 0.65],  // golden hour end
  [ 10,  [210, 175,  90], 0.58],  // low warm sun
  [ 20,  [220, 200, 150], 0.52],  // mid-morning/afternoon
  [ 45,  [235, 220, 195], 0.46],  // daytime
  [ 90,  [255, 248, 238], 0.42],  // high noon
];

function lerpSkyColor(altDeg) {
  const keys = SKY_KEYS;
  if (altDeg <= keys[0][0]) return { rgb: keys[0][1], intensity: keys[0][2] };
  if (altDeg >= keys[keys.length-1][0]) {
    const k = keys[keys.length-1];
    return { rgb: k[1], intensity: k[2] };
  }
  for (let i = 0; i < keys.length - 1; i++) {
    const [a0, c0, i0] = keys[i];
    const [a1, c1, i1] = keys[i+1];
    if (altDeg >= a0 && altDeg <= a1) {
      const t = (altDeg - a0) / (a1 - a0);
      const r = Math.round(c0[0] + (c1[0]-c0[0]) * t);
      const g = Math.round(c0[1] + (c1[1]-c0[1]) * t);
      const b = Math.round(c0[2] + (c1[2]-c0[2]) * t);
      const intensity = i0 + (i1 - i0) * t;
      return { rgb: [r,g,b], intensity };
    }
  }
  return { rgb: [255,248,238], intensity: 0.42 };
}

function rgbToHex([r,g,b]) {
  return '#' + [r,g,b].map(v => v.toString(16).padStart(2,'0')).join('');
}

function updateMapLight(altDeg, azDeg, phase) {
  if (!map.isStyleLoaded()) return;

  const polar = Math.max(1, Math.min(89, 90 - altDeg));
  const { rgb, intensity } = lerpSkyColor(altDeg);
  const hexColor = rgbToHex(rgb);

  try {
    map.setLight({
      anchor: 'map',
      color: hexColor,
      intensity,
      position: [1.5, azDeg, polar]
    });
  } catch(e) {}

  // Also tint the ray overlay canvas color to match sky
  if (lastSunData) {
    // update phase color for ray overlay to use interpolated color
    lastSunData.skyHex = hexColor;
  }

  // Tint building extrusion to pick up warm/cool cast
  // Blend building base color toward sky color slightly
  try {
    const bldR = Math.round(22 + (rgb[0]-128)*0.06);
    const bldG = Math.round(22 + (rgb[1]-128)*0.06);
    const bldB = Math.round(28 + (rgb[2]-128)*0.07);
    const bldHex = rgbToHex([
      Math.max(10, Math.min(80, bldR)),
      Math.max(10, Math.min(80, bldG)),
      Math.max(10, Math.min(90, bldB))
    ]);
    if (map.getLayer('ss-buildings')) {
      map.setPaintProperty('ss-buildings', 'fill-extrusion-color', bldHex);
    }
  } catch(e) {}
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   COMPASS CANVAS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function drawCompass(azDeg, altDeg, phase) {
  const canvas = document.getElementById('compass');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const cx = W / 2, cy = H / 2;
  const R = cx - 6;
  const bearing = map.getBearing(); // current map rotation

  ctx.clearRect(0, 0, W, H);

  // BG circle
  ctx.beginPath();
  ctx.arc(cx, cy, R, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(10,10,12,0.72)';
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Tick marks â€” rotated by bearing so N tracks true north
  for (let i = 0; i < 36; i++) {
    const a = (i / 36) * Math.PI * 2 - Math.PI / 2 - bearing * Math.PI / 180;
    const isMain = i % 9 === 0;
    const r0 = R - (isMain ? 8 : 4);
    ctx.beginPath();
    ctx.moveTo(cx + R * Math.cos(a), cy + R * Math.sin(a));
    ctx.lineTo(cx + r0 * Math.cos(a), cy + r0 * Math.sin(a));
    ctx.strokeStyle = isMain ? 'rgba(255,255,255,0.25)' : 'rgba(255,255,255,0.08)';
    ctx.lineWidth = isMain ? 1.5 : 0.8;
    ctx.stroke();
  }

  // Cardinal labels â€” also rotated
  ctx.font = '9px "DM Mono"';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  [['N', 0], ['E', 90], ['S', 180], ['W', 270]].forEach(([l, deg]) => {
    const a = (deg - 90 - bearing) * Math.PI / 180;
    ctx.fillStyle = l === 'N' ? 'rgba(220,80,80,0.9)' : 'rgba(255,255,255,0.35)';
    ctx.fillText(l, cx + (R - 16) * Math.cos(a), cy + (R - 16) * Math.sin(a));
  });

  // Sun beam gradient â€” sun position in compass space accounts for bearing
  const sunRad = (azDeg - bearing - 90) * Math.PI / 180;
  const beamLen = R - 24;
  const sunX = cx + beamLen * Math.cos(sunRad);
  const sunY = cy + beamLen * Math.sin(sunRad);

  if (altDeg > -18) {
    // Glow halo
    const grd = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, 18);
    grd.addColorStop(0, phase.color + 'aa');
    grd.addColorStop(1, 'transparent');
    ctx.beginPath();
    ctx.arc(sunX, sunY, 18, 0, Math.PI * 2);
    ctx.fillStyle = grd;
    ctx.fill();

    // Ray line
    const lineGrd = ctx.createLinearGradient(cx, cy, sunX, sunY);
    lineGrd.addColorStop(0, 'transparent');
    lineGrd.addColorStop(1, phase.color + 'cc');
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(sunX, sunY);
    ctx.strokeStyle = lineGrd;
    ctx.lineWidth = 2;
    ctx.stroke();

    // Sun dot
    ctx.beginPath();
    ctx.arc(sunX, sunY, altDeg < 0 ? 3.5 : 5, 0, Math.PI * 2);
    ctx.fillStyle = altDeg < 0 ? phase.color + '80' : phase.color;
    ctx.fill();
  }

  // Altitude arc (shows sun height)
  const altNorm = Math.max(0, Math.min(1, (altDeg + 18) / 106));
  const arcStart = Math.PI * 1.1;
  const arcEnd   = Math.PI * 1.9;
  const arcSpan  = arcEnd - arcStart;

  ctx.beginPath();
  ctx.arc(cx, cy, R - 3, arcStart, arcEnd);
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 3;
  ctx.lineCap = 'round';
  ctx.stroke();

  if (altNorm > 0) {
    ctx.beginPath();
    ctx.arc(cx, cy, R - 3, arcStart, arcStart + arcSpan * altNorm);
    ctx.strokeStyle = phase.color;
    ctx.lineWidth = 3;
    ctx.stroke();
  }

  // Center
  ctx.beginPath();
  ctx.arc(cx, cy, 3, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(237,232,223,0.45)';
  ctx.fill();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   DIRECTIONAL SUN RAY OVERLAY
   A soft gradient bloom showing where sunlight enters the scene
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function drawRayOverlay(azDeg, altDeg, phase) {
  const canvas = document.getElementById('ray-canvas');
  const W = window.innerWidth, H = window.innerHeight;
  canvas.width = W; canvas.height = H;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, W, H);

  if (altDeg < -12) {
    canvas.style.opacity = '0';
    return;
  }

  const intensity = Math.max(0, Math.min(0.18, (altDeg + 12) / 60 * 0.18));
  canvas.style.opacity = String(intensity / 0.18);

  // Sun direction: azDeg is clockwise from north
  // On screen: 0=N=top, 90=E=right, 180=S=bottom, 270=W=left
  // Map bearing can rotate this, but we simplify to map-north = screen-top
  const screenAngle = ((azDeg - map.getBearing()) % 360 + 360) % 360;
  const rad = (screenAngle - 90) * Math.PI / 180;

  // Source point on screen edge, opposite to sun direction (light comes FROM sun)
  const cx = W / 2, cy = H / 2;
  const dist = Math.max(W, H);
  const srcX = cx - Math.cos(rad) * dist * 0.9;
  const srcY = cy - Math.sin(rad) * dist * 0.9;

  // Use the interpolated sky color if available
  const rayHex = (lastSunData && lastSunData.skyHex) ? lastSunData.skyHex : phase.color;
  const grd = ctx.createRadialGradient(srcX, srcY, 0, srcX, srcY, dist * 1.1);
  grd.addColorStop(0, rayHex + '30');
  grd.addColorStop(0.4, rayHex + '0c');
  grd.addColorStop(1, 'transparent');

  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, W, H);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CAST SHADOW ENGINE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

// Debounce helper â€“ avoids hammering on every map move
function scheduleShadowUpdate(azDeg, altDeg) {
  clearTimeout(shadowUpdateTimer);
  // 400ms debounce after movement stops â€” fast enough to feel responsive,
  // long enough that queryRenderedFeatures has a painted frame to query.
  shadowUpdateTimer = setTimeout(() => computeAndRenderShadows(azDeg, altDeg), 400);
}

function clearShadowLayer() {
  if (map.getLayer('ss-shadow-layer')) map.removeLayer('ss-shadow-layer');
  if (map.getSource('ss-shadows'))     map.removeSource('ss-shadows');
}

function computeAndRenderShadows(azDeg, altDeg) {
  if (!map.isStyleLoaded()) return;

  // Sun below horizon or essentially overhead â†’ no useful cast shadows
  if (altDeg <= 1 || altDeg >= 80) { clearShadowLayer(); return; }

  const altRad = altDeg * Math.PI / 180;
  const azRad  = azDeg  * Math.PI / 180;

  // How many metres of shadow per metre of building height
  // Cap at 30Ã— so very-low sun doesn't create absurd city-spanning shadows
  const shadowScale = Math.min(1 / Math.tan(altRad), 30);

  // Shadow direction: opposite the sun azimuth
  // azimuth 0=N,90=E,180=S,270=W  â†’  sin/cos give east/north components
  const shadowDxMetresPerM = -Math.sin(azRad) * shadowScale;
  const shadowDyMetresPerM = -Math.cos(azRad) * shadowScale;

  // Metres â†’ degrees (approx, good enough at city scale)
  const cosLat = Math.cos(lat * Math.PI / 180);
  const mPerDegLat = 111320;
  const mPerDegLng = 111320 * cosLat;

  // Query all visible building features
  let features = [];
  try {
    features = map.queryRenderedFeatures({ layers: ['ss-buildings'] });
  } catch(e) { return; }

  if (!features.length) { clearShadowLayer(); return; }

  // Deduplicate by a simple id (queryRenderedFeatures can return duplicates)
  const seen = new Set();
  const unique = features.filter(f => {
    const id = JSON.stringify(f.geometry.coordinates[0] && f.geometry.coordinates[0][0]);
    if (seen.has(id)) return false;
    seen.add(id); return true;
  });

  const shadowFeatures = [];

  for (const feature of unique) {
    const geom = feature.geometry;
    if (geom.type !== 'Polygon' && geom.type !== 'MultiPolygon') continue;

    const h = parseFloat(
      feature.properties.render_height ||
      feature.properties.height ||
      feature.properties.building_height || 4
    );
    if (!h || h <= 0) continue;

    // Shadow offset in degrees for this building
    const dLng = shadowDxMetresPerM * h / mPerDegLng;
    const dLat = shadowDyMetresPerM * h / mPerDegLat;

    const rings = geom.type === 'Polygon'
      ? [geom.coordinates]
      : geom.coordinates;

    for (const polygon of rings) {
      if (!polygon || !polygon[0]) continue;
      const outer = polygon[0];

      // Build the swept shadow shape:
      // convex hull of (original footprint âˆª offset footprint)
      const pts = [];
      for (const [x, y] of outer) {
        pts.push([x,       y      ]);   // original vertex
        pts.push([x + dLng, y + dLat]); // offset vertex
      }

      const hull = convexHull(pts);
      if (hull.length < 4) continue;

      shadowFeatures.push({
        type: 'Feature',
        geometry: { type: 'Polygon', coordinates: [hull] },
        properties: { h }
      });
    }
  }

  const geojson = { type: 'FeatureCollection', features: shadowFeatures };

  // Shadow opacity: stronger when sun is low (golden hour), fade toward noon
  const opacity = Math.max(0.12, Math.min(0.42, 0.42 - (altDeg - 5) * 0.008));

  if (map.getSource('ss-shadows')) {
    map.getSource('ss-shadows').setData(geojson);
    map.setPaintProperty('ss-shadow-layer', 'fill-opacity', opacity);
  } else {
    map.addSource('ss-shadows', { type: 'geojson', data: geojson });
    // Insert BELOW building layer so shadows sit on the ground
    const beforeLayer = map.getLayer('ss-buildings') ? 'ss-buildings' : undefined;
    map.addLayer({
      id: 'ss-shadow-layer',
      type: 'fill',
      source: 'ss-shadows',
      paint: {
        'fill-color': '#000820',
        'fill-opacity': opacity,
        'fill-antialias': true
      }
    }, beforeLayer);
  }
}

/* Convex hull (gift-wrapping / Jarvis march) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function convexHull(points) {
  const n = points.length;
  if (n < 3) { const r = [...points]; r.push(r[0]); return r; }

  // Find leftmost point
  let start = 0;
  for (let i = 1; i < n; i++) {
    if (points[i][0] < points[start][0] ||
        (points[i][0] === points[start][0] && points[i][1] < points[start][1])) {
      start = i;
    }
  }

  const hull = [];
  let cur = start;
  let iters = 0;
  do {
    hull.push(points[cur]);
    let next = (cur + 1) % n;
    for (let i = 0; i < n; i++) {
      const cross =
        (points[next][0] - points[cur][0]) * (points[i][1] - points[cur][1]) -
        (points[next][1] - points[cur][1]) * (points[i][0] - points[cur][0]);
      if (cross < 0) next = i;
    }
    cur = next;
    iters++;
  } while (cur !== start && iters <= n + 2);

  hull.push(hull[0]); // close ring
  return hull;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   EVENTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
// Date/time inputs update immediately
document.getElementById('inp-date').addEventListener('input', updateAll);
document.getElementById('inp-time').addEventListener('input', updateAll);

function markClean() {} // no-op, kept so auto-tick call doesn't break

map.on('rotate', () => {
  if (lastSunData) {
    drawCompass(lastSunData.azDeg, lastSunData.altDeg, lastSunData.phase);
    drawRayOverlay(lastSunData.azDeg, lastSunData.altDeg, lastSunData.phase);
  }
});

map.on('moveend', () => {
  // Sync lat/lng to map center, then recompute shadows for new viewport
  const c = map.getCenter();
  lat = c.lat; lng = c.lng;
  if (lastSunData) {
    scheduleShadowUpdate(lastSunData.azDeg, lastSunData.altDeg);
  }
});

/* â”€â”€ Compass drag-to-rotate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
(function() {
  const wrap = document.getElementById('compass-wrap');
  const canvas = document.getElementById('compass');
  let dragging = false;
  let lastAngle = null;

  function getAngle(e, rect) {
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const dx = clientX - (rect.left + rect.width / 2);
    const dy = clientY - (rect.top + rect.height / 2);
    return Math.atan2(dy, dx) * 180 / Math.PI;
  }

  function onStart(e) {
    e.preventDefault();
    dragging = true;
    wrap.classList.add('dragging');
    lastAngle = getAngle(e, canvas.getBoundingClientRect());
  }

  function onMove(e) {
    if (!dragging) return;
    e.preventDefault();
    const angle = getAngle(e, canvas.getBoundingClientRect());
    let delta = angle - lastAngle;
    // Normalize to [-180, 180]
    if (delta > 180)  delta -= 360;
    if (delta < -180) delta += 360;
    lastAngle = angle;
    map.setBearing(map.getBearing() + delta);
  }

  function onEnd() {
    dragging = false;
    wrap.classList.remove('dragging');
    lastAngle = null;
  }

  canvas.addEventListener('mousedown',  onStart, { passive: false });
  canvas.addEventListener('touchstart', onStart, { passive: false });
  window.addEventListener('mousemove',  onMove,  { passive: false });
  window.addEventListener('touchmove',  onMove,  { passive: false });
  window.addEventListener('mouseup',   onEnd);
  window.addEventListener('touchend',  onEnd);

  // Double-click to reset north
  canvas.addEventListener('dblclick', () => {
    map.easeTo({ bearing: 0, duration: 400 });
  });
})();

document.getElementById('refresh-btn').addEventListener('click', () => {
  if (!lastSunData) return;
  const btn = document.getElementById('refresh-btn');
  btn.classList.add('spinning');
  btn.addEventListener('animationend', () => btn.classList.remove('spinning'), { once: true });
  // Wait for map to be fully idle so queryRenderedFeatures hits a painted frame
  if (map.isStyleLoaded() && !map.isMoving()) {
    computeAndRenderShadows(lastSunData.azDeg, lastSunData.altDeg);
  } else {
    map.once('idle', () => computeAndRenderShadows(lastSunData.azDeg, lastSunData.altDeg));
  }
});

document.getElementById('locate-btn').addEventListener('click', () => {
  if (!navigator.geolocation) return;
  navigator.geolocation.getCurrentPosition(pos => {
    lat = pos.coords.latitude;
    lng = pos.coords.longitude;
    map.flyTo({ center: [lng, lat], zoom: 16, duration: 1800 });
    setTimeout(updateAll, 200);
  }, () => {
    alert('Location access denied or unavailable.');
  });
});

// Redraw overlay on resize
window.addEventListener('resize', () => {
  if (lastSunData) drawRayOverlay(lastSunData.azDeg, lastSunData.altDeg, lastSunData.phase);
});

// Mobile solar drawer toggle
(function() {
  const btn = document.getElementById('mobile-solar-btn');
  const drawer = document.getElementById('mobile-solar-drawer');
  const chevron = document.getElementById('msb-chevron');
  if (!btn) return;
  let open = false;

  btn.addEventListener('click', (e) => {
    e.stopPropagation();
    open = !open;
    drawer.style.display = open ? 'block' : 'none';
    chevron.style.transform = open ? 'rotate(180deg)' : '';
  });

  // Tap outside to close
  document.addEventListener('click', (e) => {
    if (open && !drawer.contains(e.target) && e.target !== btn && !btn.contains(e.target)) {
      open = false;
      drawer.style.display = 'none';
      chevron.style.transform = '';
    }
  });
})();

// â”€â”€ Search (Nominatim / OpenStreetMap) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(function() {
  const wrap     = document.getElementById('search-wrap');
  const toggleBtn= document.getElementById('search-toggle');
  const inp      = document.getElementById('search-inp');
  const results  = document.getElementById('search-results');
  const clearBtn = document.getElementById('search-clear');
  const spinner  = document.getElementById('search-spinner');
  let debounceTimer = null;
  let activeRequest = 0;

  // Open/close the popup
  toggleBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    const isOpen = wrap.classList.toggle('open');
    if (isOpen) {
      setTimeout(() => inp.focus(), 50);
    } else {
      inp.value = '';
      clearBtn.style.display = 'none';
      results.innerHTML = '';
    }
  });

  function showResults(items) {
    if (!items.length) {
      results.innerHTML = '<div class="sr-empty">No results found</div>';
    } else {
      results.innerHTML = items.slice(0, 6).map((item, i) =>
        `<div class="sr-item" data-i="${i}">
          <div class="sr-name">${escHtml(item.display_name.split(',')[0])}</div>
          <div class="sr-detail">${escHtml(item.display_name.split(',').slice(1,4).join(',').trim())}</div>
        </div>`
      ).join('');
      results.querySelectorAll('.sr-item').forEach((el, i) => {
        el.addEventListener('click', () => selectResult(items[i]));
      });
    }
    // results are inside popup, always visible when popup is open
  }

  function selectResult(item) {
    inp.value = item.display_name.split(',')[0];
    results.innerHTML = '';
    clearBtn.style.display = 'inline';
    // collapse after selecting
    setTimeout(() => {
      wrap.classList.remove('open');
      inp.value = '';
      clearBtn.style.display = 'none';
    }, 600);

    const newLat = parseFloat(item.lat);
    const newLng = parseFloat(item.lon);
    lat = newLat; lng = newLng;

    const bbox = item.boundingbox;
    if (bbox) {
      map.fitBounds([
        [parseFloat(bbox[2]), parseFloat(bbox[0])],
        [parseFloat(bbox[3]), parseFloat(bbox[1])]
      ], { padding: 80, maxZoom: 17, duration: 1400, pitch: 52 });
    } else {
      map.flyTo({ center: [newLng, newLat], zoom: 16, pitch: 52, duration: 1400 });
    }
    setTimeout(updateAll, 300);
  }

  function escHtml(s) {
    return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  async function doSearch(q) {
    if (!q.trim()) { results.style.display = 'none'; return; }
    const reqId = ++activeRequest;
    spinner.style.display = 'block';
    try {
      const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}&limit=6&addressdetails=0`;
      const res = await fetch(url, { headers: { 'Accept-Language': 'en' } });
      if (reqId !== activeRequest) return;
      const data = await res.json();
      showResults(data);
    } catch(e) {
      if (reqId === activeRequest) {
        results.innerHTML = '<div class="sr-empty">Search unavailable</div>';
      }
    } finally {
      if (reqId === activeRequest) spinner.style.display = 'none';
    }
  }

  inp.addEventListener('input', () => {
    clearBtn.style.display = inp.value ? 'inline' : 'none';
    clearTimeout(debounceTimer);
    if (!inp.value.trim()) { results.innerHTML = ''; return; }
    debounceTimer = setTimeout(() => doSearch(inp.value), 380);
  });

  inp.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
      results.innerHTML = '';
      wrap.classList.remove('open');
      inp.value = '';
      clearBtn.style.display = 'none';
    }
    if (e.key === 'Enter') { clearTimeout(debounceTimer); doSearch(inp.value); }
  });

  clearBtn.addEventListener('click', () => {
    inp.value = '';
    clearBtn.style.display = 'none';
    results.innerHTML = '';
    inp.focus();
  });

  document.addEventListener('click', e => {
    if (!wrap.contains(e.target)) {
      results.innerHTML = '';
      wrap.classList.remove('open');
      inp.value = '';
      clearBtn.style.display = 'none';
    }
  });
})();

// Auto-tick every 60s if user hasn't changed time
let autoTick = true;
// Once user manually changes time, stop auto-ticking
['inp-date','inp-time'].forEach(id => {
  document.getElementById(id).addEventListener('input', () => { autoTick = false; });
});
setInterval(() => {
  if (autoTick) { setInputsToNow(); updateAll(); markClean(); }
}, 60000);

}); // end window load
</script>
</body>
</html>